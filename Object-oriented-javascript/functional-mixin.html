<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<script type="text/javascript">
		//https://classroom.udacity.com/courses/ud711/lessons/75276e41-b4b7-462c-881b-bf465f28485b/concepts/d4411e32-2bcf-4485-98a0-aa2f05b2bb10

		//functional mixin uses mixin and factory functions

		//mixin
		// mixin is a technique that takes the properties and methods from one object and copies them over to another object. In other words: a mixin is an technique that provides some useful functionality, but is not meant to be added to the prototype chain. The simplest way to implement the mixin pattern is to use Object.assign(). Object.assign() is a method that copies an object's own (non-inherited) properties from one or more source objects into a target object, then returns the updated target object. It provide multiple inheritance.
		let target = { letter: 'a', number: 11 };

		let source = { number: 7 };

		Object.assign(target, source);

		console.log(target);

		//factory func
		//A factory function is a function that returns an object, but isn't itself a class or constructor. As such, we invoke a factory function as a normal function without using the new operator. Using a factory function, we can easily create object instances without the complexity of classes and constructors!
		function Basketball(color) {
		  return {
		    color: color,
		    numDots: 35000
		  };
		}
		const orangeBasketball = Basketball('orange');

		console.log(orangeBasketball);
		// { color: 'orange', numDots: 35000 }

		//functional mixin
		//In the previous section, we used mixins to add features into a composite object. We also just leveraged factory functions to create objects without using the new operator or messing with prototypal inheritance. Let's combine what we've learned from mixins and factory functions and take things a step further with functional mixins!

		/*A functional mixin is a composable factory function that receives a _mixin_as an argument, copies properties and methods from that mixin, and returns a new object.*/
		function CoffeeMaker(object) {
		  let needsRefill = false;

		  return Object.assign({}, object, {
		    pourAll: function () {
		      needsRefill = true;
		    },
		    isEmpty: function () {
		      return needsRefill;
		    }
		  });
		}
		/*Note that unlike a standard factory function, which takes in individual property values as arguments -- the functional mixin actually takes in an object itself! Whichever object is passed in to the function, is merged with other objects passed into Object.assign().

		Let's pass the following percolator object into CoffeeMaker() and view the results:*/

		const mixedCoffeeMaker = CoffeeMaker({ style: 'percolator' });
		/*The returned mixedCoffeeMaker object now looks like:

		{
		  style: 'percolator',
		  pourAll: function () {
		    needsRefill = true;
		  },
		  isEmpty: function () {
		    return needsRefill;
		  }
		}*/

	</script>

</body>
</html>